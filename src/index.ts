import { app, BrowserWindow, shell, session, autoUpdater, ipcMain, screen } from "electron";
import isDev from "electron-is-dev";
import makeIpcRoutes from "./main/routes/index";
import path from "path";
import child_process from "child_process";
import fs from "fs-extra";

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

export const hasPortableFile = fs.existsSync(path.resolve(app.getPath("exe"), "..", "portable"));
export const cacheDir = hasPortableFile ? path.resolve(app.getPath("exe"), "..", "electron_cache") : path.join(app.getPath("userData"));
export const dnsFile = path.resolve(cacheDir, "dns");
export const hasDnsFile = fs.pathExistsSync(dnsFile);
let updateDownloaded = false;

ipcMain.handle("check-status", () => updateDownloaded);

// Don't use appData to store cache if zip maker used
// We can't setPath in linux appImage since it's read only, for now do this only for windows
if (process.platform === "win32" && !process.argv.join("").includes("squirrel") && hasPortableFile) {
  fs.ensureDirSync(cacheDir);
  app.setPath("userData", cacheDir);
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) { // eslint-disable-line global-require
  app.quit();
}

const gotTheLock = app.requestSingleInstanceLock();
let mainWindow: BrowserWindow;
let isPortable = false;

const handleStartupEvent = function () {
  if (process.platform !== "win32") {
    return false;
  }

  const appFolder = path.resolve(process.execPath, "..");
  const rootAtomFolder = path.resolve(appFolder, "..");
  const updateDotExe = path.resolve(path.join(rootAtomFolder, "Update.exe"));
  const exeName = path.basename(process.execPath);

  const spawn = function (command: any, args: any) {
    let spawnedProcess;

    try {
      spawnedProcess = child_process.spawn(command, args, { detached: true });
    } catch (error) {
      console.error(error);
    }

    return spawnedProcess;
  };

  const spawnUpdate = function (args: any) {
    return spawn(updateDotExe, args);
  };

  const squirrelCommand = process.argv[1];
  switch (squirrelCommand) {
    case "--squirrel-install":
      spawnUpdate(["--createShortcut", exeName]);
      return false;
    case "--squirrel-updated":
      setTimeout(app.quit, 1000);
      return true;
    case "--squirrel-uninstall":
      app.quit();
      try {
        fs.removeSync(app.getPath("userData")); // Current emusak
        fs.removeSync(path.resolve(app.getPath("userData"), "..", "emusak")); // Emusak V1
      } catch (e) {
        console.error(e);
      }
      spawnUpdate(["--removeShortcut", exeName]);
      return true;
    case "--squirrel-obsolete":
      app.quit();
      return true;
  }
};

if (handleStartupEvent()) {
  process.exit(0);
}

const shouldUseNativeMenuBar = app.commandLine.hasSwitch("native-menu-bar");

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    resizable: true,
    autoHideMenuBar: !shouldUseNativeMenuBar,
    show: false,
    frame: false,
    minHeight: 680,
    minWidth: 920,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    }
  });

  makeIpcRoutes(mainWindow);

  mainWindow.webContents.on("did-finish-load", function () {
    const displays = screen.getAllDisplays();
    const display = displays.find((d) => d.bounds.x !== 0 || d.bounds.y !== 0) || displays[0];

    mainWindow.setSize(Math.min(display.bounds.width, 1280), Math.min(display.bounds.width, 860));
    mainWindow.center();
    mainWindow.show();

    if (!isDev && process.platform === "win32") {
      const feed = `https://update.electronjs.org/CapitaineJSparrow/emusak-ui/${process.platform}-${process.arch}/${app.getVersion()}`;

      autoUpdater.setFeedURL({
        url: feed
      });

      // Check updates every 5mn, and at startup
      setInterval(() => {
        if (!isPortable) {
          autoUpdater.checkForUpdates();
        }
      }, 5 * 60 * 1000);

      try {
        autoUpdater.checkForUpdates();
      } catch(e) {
        mainWindow.webContents.send("is-portable");
        isPortable = true;
      }

      autoUpdater.on("update-available", () => mainWindow.webContents.send("update-available"));
      autoUpdater.on("update-downloaded", () => {
        updateDownloaded = true;
        mainWindow.webContents.send("update-downloaded");
      });
      ipcMain.on("reboot-after-download", () => autoUpdater.quitAndInstall());
    }
  });

  mainWindow.webContents.on("new-window", function(e, url) {
    e.preventDefault();
    shell.openExternal(url);
  });

  // and load the index.html of the app.
  const url = MAIN_WINDOW_WEBPACK_ENTRY + `?useNativeMenuBar=${shouldUseNativeMenuBar}`;
  mainWindow.loadURL(url);

  let cspHeader = "default-src 'self' https://fonts.googleapis.com/ https://fonts.gstatic.com/ 'unsafe-inline'; img-src 'self' data: https://*;";

  // "unsafe-eval" is required by webpack in development
  if (process.env.NODE_ENV === "development") {
    cspHeader = "default-src 'self' https://fonts.googleapis.com/ https://fonts.gstatic.com/ 'unsafe-inline' 'unsafe-eval'; img-src 'self' data: https://*;";
  }

  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": [cspHeader]
      }
    });
  });
};

// Do not allow application to be launched twice
if (!gotTheLock) {
  app.quit();
} else {
  app.on("second-instance", () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);
}

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
